{"version":3,"file":"easyrouter.umd.js","sources":["../src/easyrouter.es.ts"],"sourcesContent":["import * as Router from '../index.d'\n\n//#region Internal typings ---------------------------------------------------\n\ninterface Dict<T = any> { [k: string]: T }\n\ntype Params       = Router.Params\ntype Route        = Router.Route\ntype RouteContext = Router.RouteContext\n\ntype ChainedRoute = Route | Dict<Route>\ntype UnescapeFn   = (p: string) => string\n\ninterface IRouter {\n  _split?: (hash: string) => string[]\n  _normalize?: (hash: string) => string\n  _run?: (hash: string) => boolean\n  // Public API\n  add(routes: Route | Route[], cb?: Router.EnterFn): this\n  clear(): this\n  getContext(): Router.Context\n  listen(root: string): this\n  match(hash: string): RouteContext | null\n  navigate(hash: string, force?: boolean): this\n  onEnter(cb: Router.OnEnterFn): this\n  onExit(cb: Router.OnExitFn): this\n  rescue(cb: Router.RescueFn): this\n  reset(): this\n  route(path: string): Route | null\n  stop(): this\n}\n\n//#endregion\n\nconst router = (function easyRouter (window: Window, UNDEF: undefined) {\n\n  const NULL = null as null\n\n  /** Matches in $1 the hash without the first \"#/\" nor final slash */\n  const R_HASH = /^#?\\/*(.*?)\\/*$/\n\n  const S_PARM_PREFIX = ':'\n  const S_PARM_NAME   = '~'\n  const S_ROUTE_NODE  = '@'\n  const S_HASH_EVT    = 'hashchange'\n\n  const _decode = decodeURIComponent\n  const _noop   = (s: string) => s\n\n  // tslint:disable:no-var-keyword\n  var _active = false\n  var _hash   = ''\n  var _route  = NULL as RouteContext | null\n  var _routes = {} as ChainedRoute\n  // global callbacks\n  var _rescue: Router.RescueFn | undefined\n  var _onEnter: Router.OnEnterFn | undefined\n  var _onExit: Router.OnExitFn | undefined\n  // tslint:enable:no-var-keyword\n\n  /**\n   * Check if the paramater is a function.\n   */\n  // tslint:disable-next-line:ban-types\n  const _fn = <T extends Function> (fn?: T) => (typeof fn === 'function' ? fn : UNDEF)\n\n  /**\n   * Hash normalization, adds the first '#' and removes the last slash.\n   */\n  const _normalize = (hash: string) => {\n    switch (hash) {\n      case '':\n      case '#':\n        return '#'\n      case '/':\n      case '#/':\n        return '#/'\n      default:\n        return hash.replace(R_HASH, '#/$1')\n    }\n  }\n\n  /**\n   * Determinate if two route paths have the same params.\n   */\n  const _equ = (a: RouteContext, b: RouteContext) => {\n\n    // First try to avoid slow cycle\n    if (a.path.toLowerCase() !== b.path.toLowerCase()) {\n      return false\n    }\n\n    return _split(a.path).every((p) => !(\n      p[0] === S_PARM_PREFIX && (p = p.substr(1)) && a.params[p] !== b.params[p]\n    ))\n  }\n\n  /**\n   * Remove the first '#/' and trailing slashes from the given hash\n   * and return its parts.\n   */\n  const _split = (hash: string) => {\n    const parts = hash.replace(R_HASH, '$1').split('/')\n    let item\n    let i = parts.length\n\n    while (--i >= 0) {\n      item = parts[i]\n      if (!item || item === '#') {\n        parts.splice(i, 1)\n      } else if (item[0] !== S_PARM_PREFIX) {\n        parts[i] = item.toLowerCase()\n      }\n    }\n\n    return parts\n  }\n\n  /**\n   * Makes a shallow copy of route `src`.\n   * Returns `null` if `src` is falsy.\n   */\n  const _make = (src: Route | null | undefined, hash: string, params: Params) => {\n\n    if (!src) {\n      return NULL\n    }\n\n    const dest = {} as RouteContext\n    const keys = Object.keys(src)\n\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i]\n      dest[prop] = src[prop]\n    }\n\n    dest.hash = hash\n    dest.params = params\n    return dest\n  }\n\n  /**\n   * Find the route which the given hash belongs to.\n   */\n  const _seek = (part: string, hash: string, unesc: UnescapeFn) => {\n    const parts = part.replace(R_HASH, '$1').split('/')\n    const parms = {} as Params\n    let route = _routes\n    let name\n\n    for (let i = 0; i < parts.length; i++) {\n      part = unesc(parts[i])\n      name = part.toLowerCase()\n      name = name in route ? name : S_PARM_PREFIX in route ? S_PARM_PREFIX : '*'\n\n      route = route[name]\n      if (!route) {\n        return NULL\n      }\n\n      if (name === '*') {\n        break\n      }\n\n      if (route[S_PARM_NAME]) {\n        parms[route[S_PARM_NAME]] = part\n      }\n    }\n\n    return _make(route[S_ROUTE_NODE] as Route, hash, parms)\n  }\n\n  /**\n   * Parses the queryString part.\n   */\n  const _query = (route: RouteContext | null, queryStr: string, unesc: UnescapeFn) => {\n\n    if (route) {\n      const qs = queryStr.split('&')\n\n      for (let i = 0; i < qs.length; i++) {\n        const pair = qs[i].split('=')\n\n        route.params[unesc(pair[0])] = unesc(pair[1])\n      }\n    }\n\n    return route\n  }\n\n  /**\n   * Main method to define a new route.\n   *\n   * The path is normalized and converted to lower case, except the\n   * parameter names. Some examples:\n   *\n   * - '#/path/subpath'    => '#/path/subpath' (no changes)\n   * - '/path/subpath'     => '#/path/subpath' (add the first '#')\n   * - '#path/subpath'     => '#/path/subpath' (add the first '/')\n   * - '#path/SubPath'     => '#/path/subpath' (to lower case)\n   * - '#path/SubPath/:Id' => '#/path/subpath/:Id' (to lower case, except ':Id')\n   *\n   * @param {RouteContext} src\n   * @param {Callback} [enter]\n   * @returns {RouteContext} Route\n   */\n  const _add = (src: RouteContext, enter?: Router.EnterFn) => {\n    const path = _normalize(src.path)\n    let route = _routes\n\n    _split(path).forEach((part) => {\n      const parm = part[0] === S_PARM_PREFIX\n      const name = parm ? S_PARM_PREFIX : part\n\n      route = route[name] || (route[name] = {})\n      if (parm) {\n        route[S_PARM_NAME] = part.slice(1)\n      }\n    })\n\n    route = route[S_ROUTE_NODE] = { path, enter } as RouteContext\n\n    Object.keys(src).forEach((p) => {\n      if (p !== 'path') {\n        route[p] = src[p]\n      }\n    })\n\n    return R\n  }\n\n  // tslint:disable-next-line:no-var-keyword\n  var R: IRouter\n\n  /**\n   * Run the query callback if we have the same params of the previous\n   * route for the non-queryStr parts (i.e. route is already loaded).\n   */\n  const _queryAbort = (prev: RouteContext | null, next: RouteContext) => {\n\n    if (prev && prev.query &&\n        _equ(prev, next) && prev.query(next.params) === false) {\n      R.navigate(prev.hash)\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Trigged on hash changes.\n   */\n  const _run = (hash: string) => {   // tslint:disable-line:cyclomatic-complexity\n    hash = _normalize(hash)\n\n    // Must preserve the case of the hash\n    if (_hash.toLowerCase() !== hash.toLowerCase()) {\n      const prev = _route\n      const next = R.match(hash)\n\n      // Hook for query-string changes through the `query` method of the route.\n      // It runs only if we have the same params for the non-queryString parts\n      // (i.e. hash is already current).\n      if (next && _queryAbort(prev, next)) {\n        return false\n      }\n\n      // if we have a previous route, call its `exit`\n      // method and abort if `exit` returns `false`\n      if (prev && prev.exit && prev.exit(prev.params) === false) {\n        return false\n      }\n\n      // continue with the global `exit` routine.\n      if (_onExit) {\n        _onExit.call(R, prev)\n      }\n\n      // swap the current route info\n      _hash = hash\n      _route = next\n\n      // call the global enter routine\n      if (_onEnter) {\n        _onEnter.call(R, next)\n      }\n\n      // if we have a new route with a `next` method, call it and return\n      if (next && next.enter) {\n        next.enter(next.params)\n        return true\n      }\n\n      // next not found or has no `enter` method, fallback to rescue\n      if (_rescue && hash) {\n        _rescue.call(R, hash)\n      }\n    }\n\n    // no route or the current route has no changes\n    return false\n  }\n\n  /**\n   * Default handler for hash changes\n   */\n  const _handler = () => {\n    return _run(location.hash)\n  }\n\n  //#region Public API -------------------------------------------------------\n\n  R = {\n\n    /*#if process.env.BUILD === 'test'\n    _split: _split,\n    _normalize: _normalize,\n    _run: _run,\n    //#endif */\n\n    /**\n     * Register one or more routes (rules and methods).\n     *\n     * @param   {RouteContext|RouteContext[]} data Array of templates for the routes\n     * @param   {Function} [cb] Optional 'on' function\n     * @returns {this} This chainable object.\n     * @deprecated\n     */\n    add(data: RouteContext | RouteContext[], cb?: Router.EnterFn) {\n      cb = _fn(cb)\n\n      if (Array.isArray(data)) {\n        data.forEach((src) => { _add(src, cb) })\n      } else {\n        _add(data, cb)\n      }\n\n      return R\n    },\n\n    /**\n     * Empties the routes.\n     *\n     * The global callbacks (onEnter, onExit, rescue) are preserved.\n     */\n    clear() {\n      _routes = {}\n      return R\n    },\n\n    /**\n     * Returns the context of the current route, or `null` if there's no\n     * current route.\n     *\n     * @returns {RouteContext}\n     */\n    getContext() {\n      const route = _route\n      return {\n        isActive: _active,\n        lastHash: _hash,\n        lastRoute: route ? _make(route, route.hash, route.params) : null,\n        onEnter: _onEnter,\n        onExit: _onExit,\n        rescue: _rescue,\n      }\n    },\n\n    /**\n     * Start handling hash changes.\n     *\n     * `root` is the hash for URLs without a defined path to which a user\n     * will be redirected.\n     *\n     * This route will be automatically selected in the page load, unless\n     * the page already has a hash.\n     *\n     * @param   {string} [root] The \"root\" hash (default is \"#\").\n     * @returns {this} This chainable object.\n     */\n    listen(root?: string) {\n\n      // check browser haschange support\n      // istanbul ignore else\n      if ('onhashchange' in window) {\n        R.stop()\n        window.addEventListener(S_HASH_EVT, _handler, true)\n      } else {\n        throw new Error(\"easyRouter: Your browser has no 'hashchange' support\")\n      }\n\n      // normalize root\n      root = root && _normalize(root) || '#'\n\n      // set a default rescue funtion if there's no one\n      if (!_rescue) {\n        _rescue = function () { R.navigate(root!) }\n      }\n\n      // if we have a hash, run it\n      if (location.hash) {\n        _run(location.hash)\n\n      // else if we have a root, set it (it will run automatically)\n      } else {\n        R.navigate(root)\n      }\n\n      // mark the router as active\n      _active = true\n\n      return R\n    },\n\n    /**\n     * Set the global callback called when no rule matches the hash or the\n     * route has no an `enter` method.\n     *\n     * If you do not provide a `rescue` method, the router will set one to\n     * redirect your users to the \"root\" defined by the `listen` method.\n     *\n     * This lets you provide instant user feedback if they click an\n     * undefined route.\n     *\n     * @param {Function} cb Callback to execute.\n     * @returns {this} This chainable object.\n     */\n    rescue(cb: Router.RescueFn) {\n      _rescue = _fn(cb)\n      return R\n    },\n\n    /**\n     * Clears the routes and global callbacks, without stopping the router.\n     *\n     * Generally, this method will be followed by `stop` or by a re-initialization.\n     *\n     * @returns {this} This chainable object.\n     */\n    reset() {\n      _hash  = ''\n      _route = NULL\n      _rescue = _onEnter = _onExit = UNDEF\n      return R.clear()\n    },\n\n    /**\n     * Returns the route object assigned to a given rule.\n     *\n     * The parameter is the rule used to register a route, it is not the hash\n     * of the current location.\n     *\n     * The returned object does not includes the hash nor parameters values.\n     *\n     * @param {string} path Rule to match in route `path` property.\n     * @returns {Route|null}\n     */\n    route(path: string) {\n      const parts = _split(_normalize(path))\n      let route = _routes\n\n      for (let part, i = 0; i < parts.length && route; i++) {\n        part = parts[i]\n        route = route[part[0] === S_PARM_PREFIX ? S_PARM_PREFIX : part]\n      }\n\n      return route && route[S_ROUTE_NODE] as Route || NULL\n    },\n\n    /**\n     * Returns a Route object for a given hash.\n     *\n     * @param   {string} hash normalized hash\n     * @returns {RouteContext|null} `null` if href has not matching route.\n     */\n    match(hash: string) {\n      const unesc = hash.indexOf('%') < 0 ? _noop : _decode\n      const start = hash.indexOf('?')\n      const query = start < 0 ? '' : hash.substr(start + 1)\n      const path  = start < 0 ? hash : hash.substr(0, start)\n\n      return query\n        ? _query(_seek(path, hash, unesc), query, unesc)\n        : _seek(path, hash, unesc)\n    },\n\n    /**\n     * Go to the given hash.\n     *\n     * If force is true, the callback runs even if the hash is current.\n     *\n     * @param   {string}  hash The target hash\n     * @param   {Boolean} [force] `true` to always run the callback\n     * @returns {this} This chainable object.\n     */\n    navigate(hash: string, force?: boolean) {\n\n      if (force) {\n        _hash = '@'\n      }\n\n      if (force && _normalize(location.hash) === _normalize(hash)) {\n        _run(hash)\n      } else {\n        location.href = hash\n      }\n\n      return R\n    },\n\n    /**\n     * Set the global callback called _always_ that the hash changes, after\n     * the `route.query`, `route.exit` and `router.onExit` methods.\n     *\n     * The parameter received by the callback is an object with the next route\n     * data, and the default context (`this`) is the router itself.\n     *\n     * _NOTE:_\n     *\n     * This callback will be called even if there's no match for the next hash\n     * or the new location has no hash. In this cases the parameter passed to\n     * the callback will be `null`.\n     *\n     * In the last case it will be called once, when the hash is removed.\n     *\n     * @param {Function} cb Enter callback.\n     * @returns {this} This chainable object.\n     */\n    onEnter(cb: Router.OnEnterFn) {\n      _onEnter = _fn(cb)\n      return R\n    },\n\n    /**\n     * Set the global callback called when the hash changes, before the\n     * `route.enter`, `router.onEnter` and `router.rescue` methods.\n     *\n     * The parameter received by the callback is an object with the previous\n     * route data, and the default context (`this`) is the router itself.\n     *\n     * _NOTE:_\n     *\n     * This callback will be called even if there's no match for the previous\n     * hash or the previous location has no hash. In this cases the\n     * parameter passed to the callback will be `null`.\n     *\n     * @param {Function} cb Callback\n     * @returns {this} This chainable object.\n     */\n    onExit(cb: Router.OnExitFn) {\n      _onExit = _fn(cb)\n      return R\n    },\n\n    /**\n     * Stops the router.\n     *\n     * Registered routes or global callbacks are preserved.\n     *\n     * You will need to call `listen` to re-enable the router.\n     */\n    stop() {\n      _active = false\n      window.removeEventListener(S_HASH_EVT, _handler, true)\n      return R\n    },\n\n  }\n\n  //#endregion\n\n  return R.reset()\n\n})(window, void 0)\n\nexport default router\n"],"names":[],"mappings":"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"}