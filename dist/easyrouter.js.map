{"version":3,"file":"easyrouter.js","sources":["../src/easyrouter.es.ts"],"sourcesContent":["import * as Router from '../index.d'\n\n//#region Internal typings ---------------------------------------------------\n\ninterface Dict<T = any> { [k: string]: T }\n\ntype Params       = Router.Params\ntype Route        = Router.Route\ntype RouteContext = Router.RouteContext\n\ntype ChainedRoute = Route | Dict<Route>\ntype UnescapeFn   = (p: string) => string\n\ninterface IRouter {\n  _split?: (hash: string) => string[]\n  _normalize?: (hash: string) => string\n  _run?: (hash: string) => boolean\n  // Public API\n  add(routes: Route | Route[], cb?: Router.EnterFn): this\n  clear(): this\n  getContext(): Router.Context\n  listen(root: string): this\n  match(hash: string): RouteContext | null\n  navigate(hash: string, force?: boolean): this\n  onEnter(cb: Router.OnEnterFn): this\n  onExit(cb: Router.OnExitFn): this\n  rescue(cb: Router.RescueFn): this\n  reset(): this\n  route(path: string): Route | null\n  stop(): this\n}\n\n//#endregion\n\nconst router = (function easyRouter (window: Window, UNDEF: undefined) {\n\n  const NULL = null as null\n\n  /** Matches in $1 the hash without the first \"#/\" nor final slash */\n  const R_HASH = /^#?\\/*(.*?)\\/*$/\n\n  const S_PARM_PREFIX = ':'\n  const S_PARM_NAME   = '~'\n  const S_ROUTE_NODE  = '@'\n  const S_HASH_EVT    = 'hashchange'\n\n  const _decode = decodeURIComponent\n  const _noop   = (s: string) => s\n\n  // tslint:disable:no-var-keyword\n  var _active = false\n  var _hash   = ''\n  var _route  = NULL as RouteContext | null\n  var _routes = {} as ChainedRoute\n  // global callbacks\n  var _rescue: Router.RescueFn | undefined\n  var _onEnter: Router.OnEnterFn | undefined\n  var _onExit: Router.OnExitFn | undefined\n  // tslint:enable:no-var-keyword\n\n  /**\n   * Check if the paramater is a function.\n   */\n  // tslint:disable-next-line:ban-types\n  const _fn = <T extends Function> (fn?: T) => (typeof fn === 'function' ? fn : UNDEF)\n\n  /**\n   * Hash normalization, adds the first '#' and removes the last slash.\n   */\n  const _normalize = (hash: string) => {\n    switch (hash) {\n      case '':\n      case '#':\n        return '#'\n      case '/':\n      case '#/':\n        return '#/'\n      default:\n        return hash.replace(R_HASH, '#/$1')\n    }\n  }\n\n  /**\n   * Determinate if two route paths have the same params.\n   */\n  const _equ = (a: RouteContext, b: RouteContext) => {\n\n    // First try to avoid slow cycle\n    if (a.path.toLowerCase() !== b.path.toLowerCase()) {\n      return false\n    }\n\n    return _split(a.path).every((p) => !(\n      p[0] === S_PARM_PREFIX && (p = p.substr(1)) && a.params[p] !== b.params[p]\n    ))\n  }\n\n  /**\n   * Remove the first '#/' and trailing slashes from the given hash\n   * and return its parts.\n   */\n  const _split = (hash: string) => {\n    const parts = hash.replace(R_HASH, '$1').split('/')\n    let item\n    let i = parts.length\n\n    while (--i >= 0) {\n      item = parts[i]\n      if (!item || item === '#') {\n        parts.splice(i, 1)\n      } else if (item[0] !== S_PARM_PREFIX) {\n        parts[i] = item.toLowerCase()\n      }\n    }\n\n    return parts\n  }\n\n  /**\n   * Makes a shallow copy of route `src`.\n   * Returns `null` if `src` is falsy.\n   */\n  const _make = (src: Route | null | undefined, hash: string, params: Params) => {\n\n    if (!src) {\n      return NULL\n    }\n\n    const dest = {} as RouteContext\n    const keys = Object.keys(src)\n\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i]\n      dest[prop] = src[prop]\n    }\n\n    dest.hash = hash\n    dest.params = params\n    return dest\n  }\n\n  /**\n   * Find the route which the given hash belongs to.\n   */\n  const _seek = (part: string, hash: string, unesc: UnescapeFn) => {\n    const parts = part.replace(R_HASH, '$1').split('/')\n    const parms = {} as Params\n    let route = _routes\n    let name\n\n    for (let i = 0; i < parts.length; i++) {\n      part = unesc(parts[i])\n      name = part.toLowerCase()\n      name = name in route ? name : S_PARM_PREFIX in route ? S_PARM_PREFIX : '*'\n\n      route = route[name]\n      if (!route) {\n        return NULL\n      }\n\n      if (name === '*') {\n        break\n      }\n\n      if (route[S_PARM_NAME]) {\n        parms[route[S_PARM_NAME]] = part\n      }\n    }\n\n    return _make(route[S_ROUTE_NODE] as Route, hash, parms)\n  }\n\n  /**\n   * Parses the queryString part.\n   */\n  const _query = (route: RouteContext | null, queryStr: string, unesc: UnescapeFn) => {\n\n    if (route) {\n      const qs = queryStr.split('&')\n\n      for (let i = 0; i < qs.length; i++) {\n        const pair = qs[i].split('=')\n\n        route.params[unesc(pair[0])] = unesc(pair[1])\n      }\n    }\n\n    return route\n  }\n\n  /**\n   * Main method to define a new route.\n   *\n   * The path is normalized and converted to lower case, except the\n   * parameter names. Some examples:\n   *\n   * - '#/path/subpath'    => '#/path/subpath' (no changes)\n   * - '/path/subpath'     => '#/path/subpath' (add the first '#')\n   * - '#path/subpath'     => '#/path/subpath' (add the first '/')\n   * - '#path/SubPath'     => '#/path/subpath' (to lower case)\n   * - '#path/SubPath/:Id' => '#/path/subpath/:Id' (to lower case, except ':Id')\n   *\n   * @param {RouteContext} src\n   * @param {Callback} [enter]\n   * @returns {RouteContext} Route\n   */\n  const _add = (src: RouteContext, enter?: Router.EnterFn) => {\n    const path = _normalize(src.path)\n    let route = _routes\n\n    _split(path).forEach((part) => {\n      const parm = part[0] === S_PARM_PREFIX\n      const name = parm ? S_PARM_PREFIX : part\n\n      route = route[name] || (route[name] = {})\n      if (parm) {\n        route[S_PARM_NAME] = part.slice(1)\n      }\n    })\n\n    route = route[S_ROUTE_NODE] = { path, enter } as RouteContext\n\n    Object.keys(src).forEach((p) => {\n      if (p !== 'path') {\n        route[p] = src[p]\n      }\n    })\n\n    return R\n  }\n\n  // tslint:disable-next-line:no-var-keyword\n  var R: IRouter\n\n  /**\n   * Run the query callback if we have the same params of the previous\n   * route for the non-queryStr parts (i.e. route is already loaded).\n   */\n  const _queryAbort = (prev: RouteContext | null, next: RouteContext) => {\n\n    if (prev && prev.query &&\n        _equ(prev, next) && prev.query(next.params) === false) {\n      R.navigate(prev.hash)\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Trigged on hash changes.\n   */\n  const _run = (hash: string) => {   // tslint:disable-line:cyclomatic-complexity\n    hash = _normalize(hash)\n\n    // Must preserve the case of the hash\n    if (_hash.toLowerCase() !== hash.toLowerCase()) {\n      const prev = _route\n      const next = R.match(hash)\n\n      // Hook for query-string changes through the `query` method of the route.\n      // It runs only if we have the same params for the non-queryString parts\n      // (i.e. hash is already current).\n      if (next && _queryAbort(prev, next)) {\n        return false\n      }\n\n      // if we have a previous route, call its `exit`\n      // method and abort if `exit` returns `false`\n      if (prev && prev.exit && prev.exit(prev.params) === false) {\n        return false\n      }\n\n      // continue with the global `exit` routine.\n      if (_onExit) {\n        _onExit.call(R, prev)\n      }\n\n      // swap the current route info\n      _hash = hash\n      _route = next\n\n      // call the global enter routine\n      if (_onEnter) {\n        _onEnter.call(R, next)\n      }\n\n      // if we have a new route with a `next` method, call it and return\n      if (next && next.enter) {\n        next.enter(next.params)\n        return true\n      }\n\n      // next not found or has no `enter` method, fallback to rescue\n      if (_rescue && hash) {\n        _rescue.call(R, hash)\n      }\n    }\n\n    // no route or the current route has no changes\n    return false\n  }\n\n  /**\n   * Default handler for hash changes\n   */\n  const _handler = () => {\n    return _run(location.hash)\n  }\n\n  //#region Public API -------------------------------------------------------\n\n  R = {\n\n    /*#if process.env.BUILD === 'test'\n    _split: _split,\n    _normalize: _normalize,\n    _run: _run,\n    //#endif */\n\n    /**\n     * Register one or more routes (rules and methods).\n     *\n     * @param   {RouteContext|RouteContext[]} data Array of templates for the routes\n     * @param   {Function} [cb] Optional 'on' function\n     * @returns {this} This chainable object.\n     * @deprecated\n     */\n    add(data: RouteContext | RouteContext[], cb?: Router.EnterFn) {\n      cb = _fn(cb)\n\n      if (Array.isArray(data)) {\n        data.forEach((src) => { _add(src, cb) })\n      } else {\n        _add(data, cb)\n      }\n\n      return R\n    },\n\n    /**\n     * Empties the routes.\n     *\n     * The global callbacks (onEnter, onExit, rescue) are preserved.\n     */\n    clear() {\n      _routes = {}\n      return R\n    },\n\n    /**\n     * Returns the context of the current route, or `null` if there's no\n     * current route.\n     *\n     * @returns {RouteContext}\n     */\n    getContext() {\n      const route = _route\n      return {\n        isActive: _active,\n        lastHash: _hash,\n        lastRoute: route ? _make(route, route.hash, route.params) : null,\n        onEnter: _onEnter,\n        onExit: _onExit,\n        rescue: _rescue,\n      }\n    },\n\n    /**\n     * Start handling hash changes.\n     *\n     * `root` is the hash for URLs without a defined path to which a user\n     * will be redirected.\n     *\n     * This route will be automatically selected in the page load, unless\n     * the page already has a hash.\n     *\n     * @param   {string} [root] The \"root\" hash (default is \"#\").\n     * @returns {this} This chainable object.\n     */\n    listen(root?: string) {\n\n      // check browser haschange support\n      // istanbul ignore else\n      if ('onhashchange' in window) {\n        R.stop()\n        window.addEventListener(S_HASH_EVT, _handler, true)\n      } else {\n        throw new Error(\"easyRouter: Your browser has no 'hashchange' support\")\n      }\n\n      // normalize root\n      root = root && _normalize(root) || '#'\n\n      // set a default rescue funtion if there's no one\n      if (!_rescue) {\n        _rescue = function () { R.navigate(root!) }\n      }\n\n      // if we have a hash, run it\n      if (location.hash) {\n        _run(location.hash)\n\n      // else if we have a root, set it (it will run automatically)\n      } else {\n        R.navigate(root)\n      }\n\n      // mark the router as active\n      _active = true\n\n      return R\n    },\n\n    /**\n     * Set the global callback called when no rule matches the hash or the\n     * route has no an `enter` method.\n     *\n     * If you do not provide a `rescue` method, the router will set one to\n     * redirect your users to the \"root\" defined by the `listen` method.\n     *\n     * This lets you provide instant user feedback if they click an\n     * undefined route.\n     *\n     * @param {Function} cb Callback to execute.\n     * @returns {this} This chainable object.\n     */\n    rescue(cb: Router.RescueFn) {\n      _rescue = _fn(cb)\n      return R\n    },\n\n    /**\n     * Clears the routes and global callbacks, without stopping the router.\n     *\n     * Generally, this method will be followed by `stop` or by a re-initialization.\n     *\n     * @returns {this} This chainable object.\n     */\n    reset() {\n      _hash  = ''\n      _route = NULL\n      _rescue = _onEnter = _onExit = UNDEF\n      return R.clear()\n    },\n\n    /**\n     * Returns the route object assigned to a given rule.\n     *\n     * The parameter is the rule used to register a route, it is not the hash\n     * of the current location.\n     *\n     * The returned object does not includes the hash nor parameters values.\n     *\n     * @param {string} path Rule to match in route `path` property.\n     * @returns {Route|null}\n     */\n    route(path: string) {\n      const parts = _split(_normalize(path))\n      let route = _routes\n\n      for (let part, i = 0; i < parts.length && route; i++) {\n        part = parts[i]\n        route = route[part[0] === S_PARM_PREFIX ? S_PARM_PREFIX : part]\n      }\n\n      return route && route[S_ROUTE_NODE] as Route || NULL\n    },\n\n    /**\n     * Returns a Route object for a given hash.\n     *\n     * @param   {string} hash normalized hash\n     * @returns {RouteContext|null} `null` if href has not matching route.\n     */\n    match(hash: string) {\n      const unesc = hash.indexOf('%') < 0 ? _noop : _decode\n      const start = hash.indexOf('?')\n      const query = start < 0 ? '' : hash.substr(start + 1)\n      const path  = start < 0 ? hash : hash.substr(0, start)\n\n      return query\n        ? _query(_seek(path, hash, unesc), query, unesc)\n        : _seek(path, hash, unesc)\n    },\n\n    /**\n     * Go to the given hash.\n     *\n     * If force is true, the callback runs even if the hash is current.\n     *\n     * @param   {string}  hash The target hash\n     * @param   {Boolean} [force] `true` to always run the callback\n     * @returns {this} This chainable object.\n     */\n    navigate(hash: string, force?: boolean) {\n\n      if (force) {\n        _hash = '@'\n      }\n\n      if (force && _normalize(location.hash) === _normalize(hash)) {\n        _run(hash)\n      } else {\n        location.href = hash\n      }\n\n      return R\n    },\n\n    /**\n     * Set the global callback called _always_ that the hash changes, after\n     * the `route.query`, `route.exit` and `router.onExit` methods.\n     *\n     * The parameter received by the callback is an object with the next route\n     * data, and the default context (`this`) is the router itself.\n     *\n     * _NOTE:_\n     *\n     * This callback will be called even if there's no match for the next hash\n     * or the new location has no hash. In this cases the parameter passed to\n     * the callback will be `null`.\n     *\n     * In the last case it will be called once, when the hash is removed.\n     *\n     * @param {Function} cb Enter callback.\n     * @returns {this} This chainable object.\n     */\n    onEnter(cb: Router.OnEnterFn) {\n      _onEnter = _fn(cb)\n      return R\n    },\n\n    /**\n     * Set the global callback called when the hash changes, before the\n     * `route.enter`, `router.onEnter` and `router.rescue` methods.\n     *\n     * The parameter received by the callback is an object with the previous\n     * route data, and the default context (`this`) is the router itself.\n     *\n     * _NOTE:_\n     *\n     * This callback will be called even if there's no match for the previous\n     * hash or the previous location has no hash. In this cases the\n     * parameter passed to the callback will be `null`.\n     *\n     * @param {Function} cb Callback\n     * @returns {this} This chainable object.\n     */\n    onExit(cb: Router.OnExitFn) {\n      _onExit = _fn(cb)\n      return R\n    },\n\n    /**\n     * Stops the router.\n     *\n     * Registered routes or global callbacks are preserved.\n     *\n     * You will need to call `listen` to re-enable the router.\n     */\n    stop() {\n      _active = false\n      window.removeEventListener(S_HASH_EVT, _handler, true)\n      return R\n    },\n\n  }\n\n  //#endregion\n\n  return R.reset()\n\n})(window, void 0)\n\nexport default router\n"],"names":[],"mappings":"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"}